[[CH-Beam_loader]]
== BEAM 加载器

// Translation to internal format.
//   Rewrites
//
// Linking and Exports

=== 从通用指令变换为特定指令

BEAM 加载器不只是获取外部 BEAM 格式并将其写入内存。它还对代码进行许多变换，并将外部 (通用) 格式转换为内部 (特定) 格式。

加载器的代码可以在 beam_load.c (在 +erts/emulator/beam+ ) 中找到，但是大多数翻译逻辑都在文件 ops.tab (在 +erts/emulator/beam/emu+ ) 中。

加载器的第一步是解析 beam 文件，基本上和我们在 xref:CH-beam_modules[] 中使用 Erlang 所做的工作相同，但是该程序是用 C 编写的。

然后是 ops.tab 中的规则被应用于代码块 (译注：code chuck, 见 xref:code_chunk[] ) 中的指令，以将通用指令转换为一个或多个特定指令。

翻译表通过模式匹配工作。文件中的每一行都定义了一个或多个带参数的通用指令的模式，可选的一个箭头(译注："=>" 符号)，后面跟着一个或多个要转换的指令。

ops tab 中的转换尝试处理编译器生成的指令模式，通过窥孔优化将它们优化为更少的特定指令。ops tab 转换尝试为选择的模式生成跳转表。

ops.tab 文件并不是在运行时解析的，而是从 ops.tab 生成一个模式匹配程序，并存储在生成的一个 C 文件中的数组中。perl 脚本 +beam_makeops+ (在 +erts/emulator/utils+ 中) 在 +beam_opcodes.h+ 和 +beam_opcodes.c+ 文件中生成一组特定于目标的操作码和翻译程序(这些文件在给定的目标目录中，例如  +erts/emulator/x86_64-unknown-linux-gnu/opt/smp/+)。

同一个程序 (beam_makeops) 还为编译器后端 +beam_opcodes.erl+ 生成 Erlang 代码。

=== 理解 ops.tab

https://github.com/erlang/otp/blob/OTP-23.1/erts/emulator/beam/ops.tab[`ops.tab`] 中的变换按照它们写入文件的顺序执行。因此，就像在 Erlang 模式匹配中一样，不同规则的触发顺序是自上而下的。

在 `ops.tab` 中的指令参数的类型可以在 xref:AP-Instructions[] 中可以找到。

==== 变换

`ops.tab` 中的大多数规则是不同指令之间的变换。一个简单的变换是这样的:

....
move S x==0 | return => move_return S
....

这组合了从任何位置移动到 `x(0)` 的 `move` 指令和 return 指令，成为一个名为 `move_return` 的单指令。让我们把变换分开看看不同的部分做了什么。

move:: is the instruction that the pattern first has to match. This can be either
a generic instruction that the compiler has emitted, or a temporary instruction
that `ops.tab` has emitted to help with transformations.

S:: is a variable binding any type of value. Any value in the pattern (left hand side or `=>`)
that is used in the generator (right hand side of `=>`) has to be bound to a variable.

x==0:: is a guard that says that we only apply the transformation if the target
location is an `x` register with the value `0`. It is possible to chain multiple
types and also bind a variable here. For instance `D=xy==0` would allow both
`x` and `y` registers with a value of `0` and also bind the argument to the variable `D`.

|:: signifies the end of this instruction and the beginning of another instruction
that is part of the same pattern.

return:: is the second instruction to match in this pattern.

`=>`:: signifies the end of the pattern and the start of the code that is to be
generated.

move_return S:: is the name of the generated instruction together with the name of
the variable on the lhs. It is possible to generate
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/ops.tab#L625[multiple instructions]
as part of a transformation by using the `|` symbol.

[[complex_example]]
.A more complex example

More complex translations can be done in `ops.tab`. For instance take the
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/ops.tab#L127-L182[`select_val`]
instruction. It will be translated by the loader into either a jump table, a linear
search array or a binary search array depending on the input values.

....
is_integer Fail=f S | select_val S=s Fail=f Size=u Rest=* | \
  use_jump_tab(Size, Rest) => gen_jump_tab(S, Fail, Size, Rest)
....

The above transformation creates a jump table if possible of the `select_val`.
There are a bunch of new techniques used in the transformations.

S:: is used in both `is_integer` and `select_val`. This means that both the
values have to be of the same type and have the same value. Furthermore the `S=s` guard
limits the type to a be a source register.
Rest=*:: allows a variable number of arguments in the instruction and binds them to
variable `Rest`.
use_jump_tab(Size, Rest):: calls the
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/beam_load.c#L2707[use_jump_tab]
C function in `beam_load.c` that decides whether the arguments in the `select_val`
can be transformed into a jump table.
\:: signifies that the transformation rule continues on the next line.
gen_jump_tab(S, Fail, Size, Rest):: calls the
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/beam_load.c#L3692[gen_jump_tab]
C function in `beam_load.c` that takes care of generating the appropriate instruction.

==== 特定指令

When all transformations are done, we have to decide how the specifc instruction should
look like. Let's continue to look at `move_return`:

....
%macro: move_return MoveReturn -nonext
move_return x
move_return c
move_return n
....

This will generate three different instructions that will use the
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/beam_emu.c#L636[`MoveReturn`]
macro in `beam_emu.c` to do the work.

%macro: move_return:: this tells `ops.tab` to generate the code for `move_return`. If there
is no `%macro` line, the instruction has to be implemented by hand in beam_emu.c. The code
for the instruction will be places in `beam_hot.h` or `beam_cold.h` depending on if the
`%hot` or `%cold` directive is active.

MoveReturn:: tells the code generator to that the name of the c-macro in beam_emu.c to use
is MoveReturn. This macro has to be implemented manually.

-nonext:: tells the code generator that it should not generate a dispatch to the next
instruction, the `MoveReturn` macro will take care of that.

move_return x:: tells the code generator to generate a specific instruction for when the
instruction argument is an x register. `c` for when it is a constant, `n` when it is `NIL`.
No instructions are in this case generated for when the argument is a y register as the
compiler will never generate such code.

The resulting code in `beam_hot.h` will look like this:

[source, C]
-----------------------------
OpCase(move_return_c):
    {
    MoveReturn(Arg(0));
    }

OpCase(move_return_n):
    {
    MoveReturn(NIL);
    }

OpCase(move_return_x):
    {
    MoveReturn(xb(Arg(0)));
    }
-----------------------------

All the implementor has to do is to define the `MoveReturn` macro in `beam_emu.c` and
the instruction is complete.

[[macro_arguments]]
.Macro flags

The `%macro` rules can take multiple different flags to modify the code that
gets generated.

The examples below assume that there is a specific instructions looking like this:

....
%macro move_call MoveCall
move_call x f
....

without any flags to the `%macro` we the following code will be generated:

[source, C]
BeamInstr* next;
PreFetch(2, next);
MoveCall(Arg(0));
NextPF(2, next);

[NOTE]
The https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/beam_emu.c#L519-L523[PreFetch and NextPF]
macros make sure to load the address to jump to next before the instruction is executed.
This trick increases performance on all architectures by a variying amount depending on
cache architecture and super scalar properties of the CPU.

-nonext:: Don't emit a dispatch for this instructions. This is used for instructions
that are known to not continue with the next instructions, i.e. return, call, jump.

`%macro move_call MoveCall -nonext`
[source, C]
MoveCall(xb(Arg(0)));

-arg_*:: Include the arguments of type * as arguments to the c-macro. Not all argument
types are included by default in the c-macro. For instance the type `f` used for fail
labels and local function calls is not included. So giving the option `-arg_f` will
include that as an argument to the c-macro.

`%macro move_call MoveCall -arg_f`
[source, C]
MoveCall(xb(Arg(0)), Arg(1));

-size:: Include the size of the instruction as an argument to the c-macro.

`%macro move_call MoveCall -size`
[source, C]
MoveCall(xb(Arg(0)), 2);

-pack:: Pack any arguments if possible. This places multiple register arguments in
the same word if possible. As register arguments can only be 0-1024, we only need
10 bits to store them + 2 for tagging. So on a 32-bit system we can put 2 registers
in one word, while on a 64-bit we can put 4 registers in one word. Packing instruction
can greatly decrease the memory used for a single instruction. However there is
also a small cost to unpack the instruction, which is why it is not enabled
for all instructions.

The example with the call cannot do any packing as `f` cannot be packed and only one
other argument exists. So let's look at the
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/ops.tab#L539[put_list]
instruction as an example instead.

....
%macro:put_list PutList -pack
put_list x x x
....

[source, C]
BeamInstr tmp_packed1;
BeamInstr* next;
PreFetch(1, next);
tmp_packed1 = Arg(0);
PutList(xb(tmp_packed1&BEAM_TIGHT_MASK),
        xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK),
        xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))));
NextPF(1, next);

This packs the 3 arguments into 1 machine word, which halves the required memory
for this instruction.

-fail_action:: Include a fail action as an argument to the c-macro. Note that the
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/beam_emu.c#L2996-L2998[`ClauseFail()`]
macro assumes the fail label is in the first argument of the instructions,
so in order to use this in the above example we should transform
the `move_call x f` to `move_call f x`.

`%macro move_call MoveCall -fail_action`
[source, C]
MoveCall(xb(Arg(0)), ClauseFail());

-gen_dest:: Include a
https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/beam_emu.c#L166-L174[store function]
as an argument to the c-macro.

`%macro move_call MoveCall -gen_dest`
[source, C]
MoveCall(xb(Arg(0)), StoreSimpleDest);

-goto:: Replace the normal next dispatch with a jump to a c-label inside beam_emu.c

`%macro move_call MoveCall -goto:do_call`
[source, C]
MoveCall(xb(Arg(0)));
goto do_call;

=== 优化

加载器在加载代码时执行许多窥孔优化。其中最重要的是指令组合和指令专门化。

指令组合是将两条或多条较小的指令合并成一条较大的指令。如果已知这些指令大部分时间都是相互跟随的，那么这可能会导致代码的速度大大加快。之所以能够加快速度，是因为不再需要在指令之间执行分派 ( dispatch，译注：参见 xref:SEC-Dispatch_directly_threaded_code[] )，而且 C 编译器在优化指令时可以获得更多信息。何时执行指令组合是一种权衡，必须考虑主仿真器循环增大的大小与执行指令时的增益之间的影响。

指令专门化消除了对指令中的参数进行解码的需要。因此，用已经解码的参数生成的将不是一条 `move_sd` ，而是 `move_xx`， `move_xy` 等指令。这减少了指令的解码成本，但这也是对仿真器代码大小的权衡考量。

==== select_val 优化

编译器生成 `select_val` 指令来对许多函数或 case 子句进行控制流处理。例如：

[source, erlang]
select(1) -> 3;
select(2) -> 3;
select(_) -> error.

编译为：

[source, erlang]
{function, select, 1, 2}.
  {label,1}.
    {line,[{location,"select.erl",5}]}.
    {func_info,{atom,select},{atom,select},1}.
  {label,2}.
    {test,is_integer,{f,4},[{x,0}]}.
    {select_val,{x,0},{f,4},{list,[{integer,2},{f,3},{integer,1},{f,3}]}}.
  {label,3}.
    {move,{integer,3},{x,0}}.
    return.
  {label,4}.
    {move,{atom,error},{x,0}}.
    return.

The values in the condition are only allowed to be either integers
or atoms. If the value is of any other type the compiler will not emit a
`select_val` instruction. The loader uses a couple of hearistics to figure
out what type algorithm to use when doing the `select_val`.

jump_on_val:: Create a jump table and use the value as the index. This if very
efficient and happens when a group of close together integers are used as the
value to select on. If not all values are present, the jump table is padded with
extra fail label slots.

select_val2:: Used when only two values are to be selected upon and they to not
fit in a jump table.

select_val_lins:: Do a linear search of the sorted atoms or integers. This is
used when a small amount of atoms or integers are to be selected from.

select_val_bins:: Do a binary search of the sorted atoms or integers.

==== 字面值预哈希

当加载一个字面值并将其用作任何需要字面值 hash 值的 bifs 或指令的参数时，该 hash 值由加载器创建并由指令使用，而不是每次都对字面值进行 hash。

使用这种技术的代码示例有 maps 指令和进程字典 (PD) bifs。

