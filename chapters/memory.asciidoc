[[CH-Memory]]
== 内存子系统: 栈、堆以及垃圾收集

在深入研究 ERTS 的内存子系统之前，我们需要有一些基本的词汇表，并了解现代操作系统中程序内存布局的一般情形。在这个回顾部分中，我将假设程序被编译成一个 ELF 可执行文件，并运行在类似 IA-32 / AMD64 架构的 Linux 上。布局和术语对于编译ERTS的所有操作系统基本上是相同的。

一个程序的内存布局看起来像这样：

[[program_memory_layout]]
.Program Memory Layout

[ditaa]
----
 high
 addresses
        +--------------+
        |   Arguments  |
        |     ENV      |
        +--------------+
        |    Stack     | --+
        |      |       |   | Can grow
        |      v       |   | dynamically
        |              | --+
        +--------------+
        |              | -------------------------------+
        +--------------+                                |
        |    memory    |                                |
        |      map     | -- files or anonymous          |
        |    segment   |                                |
        +--------------+                                |
        |              |                                | Memory
        +--------------+                                | Mapping
        | Thread Stack | --+                            | Region
        |      |       |   | Statically allocated       |
        |      v       |   | on thread start.           |
        |              | --+                            |
        +--------------+                                |
        |              |                                |
        +--------------+                                |
        | Thread Stack | --+                            |
        |      |       |   | Statically allocated       |
        |      v       |   | on thread start.           |
        |              | --+                            |
        +--------------+                                |
        |              | -------------------------------+
        +--------------+ brk
        |              | --+
        |      ^       |   | Can grow
        |      |       |   | dynamically
        |     Heap     | --+
        +--------------+ start_brk
        |     BSS      | --  Static variables initialized to zero
        +--------------+
        |     Data     | --+
        +--------------+   | Binary (disk image)
        |     Code     | --+
        +--------------+
 low
 addresses


----

尽管这幅图看起来令人生畏，但它仍然是一种简化。(要想全面理解内存子系统，请阅读《深入理解Linux内核》或《Linux系统编程》之类的书) 我想让您了解的是，有两种类型的动态分配内存：堆和内存映射段 ( memory mapped segments ) 。从现在开始，我将尝试将这个堆称为 C-堆，以区别于 Erlang 进程堆。我会将一个内存映射段称为“段”，而这张图中的任何栈为 C-栈。

C-堆通过 malloc 分配，段通过mmap分配。

****

关于内存图示

在绘制系统内存和堆栈的概览图示时，我们将遵循内存地址向上增长的惯例。即页面底部的低内存地址和页面顶部的高内存地址。(栈通常从高地址开始向下增长，因此新元素被压栈到最低地址。)

但是，当我们绘制 c-结构体 ( structure ) 时，我们将从上往下绘制字段，尽管结构的第一个字段位于最低地址，而下面的字段位于更高地址。所以包含结构体的图示中，低地址的结构体在页面的顶部，高地址的结构体在页面的底部。

这意味着 c-结构体的图示和内存区域的图示将在页面的地址位置上呈镜像。当我们试图在同一幅图中描绘结构体和堆时，就有点令人困惑。

****

=== 内存子系统

当我们深入到内存子系统中时，我们就可以再次清楚地看到，ERTS 更像是一个操作系统，而不仅仅是一个编程语言环境。ERTS 不仅为 Erlang 进程级别上的 Erlang 项式提供了一个垃圾收集器，而且还提供了大量的低级别内存分配器和内存分配策略。

有关内存分配器的概述，请参阅 erts_alloc 文档：http://www.erlang.org/doc/man/erts_alloc.html

所有这些分配器都带有一些参数，可以用来调整它们的行为，从操作的角度来看，这可能是它最重要的方面之一。在这里，我们可以配置系统行为，以适应从小型嵌入式控制系统 (如 Raspberry Pi)到 Internet 规模的 2TB 的数据库服务器的任何设备。

目前有 11 种不同的分配器，6 种不同的分配策略，以及超过 18 种其他设置，其中一些采用任意的数值输入。这意味着可能的配置有无限多。(好吧，严格地说，它不是无限的，因为每个数字都是有界的，但比你想象的要多。)

为了能够以有意义的方式使用这些设置，我们必须了解这些分配器是如何工作的，以及每个设置如何影响分配器的性能。

erts_alloc 手册给出了以下警告：

[quote, Ericsson AB, http://www.erlang.org/doc/man/erts_alloc.html]

____
WARNING: 只在你绝对清楚自己在做什么的时候使用这些标记。不适当的设置可能导致严重的性能降级甚至操作中的系统崩溃。

____

让你绝对确信你知道自己在做什么，这就是本章要讲的。

当然，我们还将详细介绍垃圾收集器的工作原理。

Oh yes, we will also go into details of how the garbage collector
works.

[[SS-Memory_Allocators]]
=== 不同类型的内存分配器

Erlang 运行时系统正在尽最大努力处理所有情况和所有类型的负载下的内存，但是总会有一些极端情况。在本章中，我们将详细了解内存是如何分配的，以及不同的分配器是如何工作的。有了这个知识和我们稍后将介绍的一些工具，如果您的系统最终出现这些情况，您应该能够检测并修复这些问题。

这里有一个关于系统可能遇到的问题以及如何分析和纠正这种行为的好故事，请阅读 Fred Hébert 的文章 https://blog.heroku.com/archives/2013/11/7/logplex-down-the-rabbit-hole["Troubleshooting Down the Logplex Rabbit Hole"]。

当我们在本书中讨论内存分配器时，它在我们脑海中有一个特定的含义。每个内存分配器管理特定类型的内存的分配和释放。每个分配器用于特定类型的数据，通常专门用于一种大小的数据。

每个内存分配器实现了可以为实际内存分配使用不同算法和设置的分配器接口。

使用不同的分配器的目的是通过分组相同大小的内存分配来减少碎片，并通过降低频繁分配的操作成本来提高性能。

有两种特别的，基本的或通用的内存分配器类型 sys_alloc 和 mseg_alloc，以及通过 alloc_util 框架实现的 9 种特定的分配器。

在下面的小节中，我们将介绍不同的分配器，并稍微介绍一下分配器的通用框架 ( alloc_util )。

每个分配器都有在文档和 C 代码中使用的几个名称。xref:table-allocators[] 列出了所有分配器及其名称。在 C 代码中使用 C-name 来引用分配器。在 erl_alloc.types 中使用了 Type-name，以将分配类型绑定到分配器。Flag 是在启动 Erlang 时用于设置分配器参数的字母。

.内存分配器列表
[[table-allocators]]
[options="header"]
|===============================================================================
|Name                    | Description           | C-name     | Type-name | Flag
| Basic allocator        | malloc interface      | sys_alloc  | SYSTEM    | Y
|Memory segment allocator| mmap interface        | mseg_alloc | -         | M
| Temporary allocator    | Temporary allocations | temp_alloc | TEMPORARY | T
| Heap allocator         | Erlang heap data      | eheap_alloc| EHEAP     | H
| Binary allocator       | Binary data           |binary_alloc| BINARY    | B
| ETS allocator          | ETS data              | ets_alloc  | ETS       | E
| Driver allocator       | Driver data           |driver_alloc| DRIVER    | R
| Short lived allocator  | Short lived memory    | sl_alloc   |SHORT_LIVED| S
| Long lived allocator   | Long lived memory     | ll_alloc   |LONG_LIVED | L
| Fixed allocator        | Fixed size data       | fix_alloc  |FIXED_SIZE | F
| Standard allocator     | For most other data   | std_alloc  | STANDARD  | D
|===============================================================================



==== 基础分配器：sys_alloc

分配器 sys_alloc 不能被禁用，它基本上是直接映射到底层 OS 的 libc 中的 malloc 实现。

如果禁用其他某个特定的分配器，在分配内存时就使用 sys_alloc 作为替代。

所有特定的分配器都根据需要，使用 sys_alloc 或 mseg_alloc 从操作系统分配内存。

当从 OS 分配内存时，sys_alloc 可以在请求的分配数目基础上，添加某个固定数目的额外大小 ( 可能为KB级 ) 作为填充。这样做可以通过过度分配内存来减少系统调用的数量。默认填充大小为 0。

当内存被释放时，sys_alloc 将在释放内存时，在进程中保留一些已经分配的一些空闲内存。这个空闲内存的大小称为对齐阈值，默认为128 KB。这也减少了系统调用的数量，但代价是占用更多的内存。这意味着，如果您使用默认设置运行系统，您可以体验到，当内存被释放时，Beam 进程不会将内存直接返回给操作系统。

sys_alloc 分配的内存区域存储在 beam 进程的 C-堆 中，堆将根据需要通过 brk() 系统调用 (译注：可以参考 link: https://man7.org/linux/man-pages/man2/brk.2.html[brk(2) — Linux manual page] ) 增长 (译注：回顾一下图：xref:program_memory_layout[program_memory_layout] )。

==== 内存段分配器：mseg_alloc

如果底层操作系统支持 mmap，那么某些特定的内存分配器可以使用 mseg_alloc 而不是 sys_alloc 来从操作系统分配内存。

通过 mseg_alloc 分配的内存区域称为段。当一个段被释放时，它不会立即返回到操作系统，而是保存在段缓存中。

当分配一个新的段时，如果可能的话，缓存的段将被重用，就是说重用的一个条件是：如果某个被缓存的段与所请求分配的段的大小相同或缓存段大于请求分配段的大小，但又“不太大”。不太大的含义是 _absolute max cache bad fit_ 的值与差值的比较结果，差值小于这个值将被认为差值“不太大”。这个默认值是 4096 KB。

为了不重用一个 4096 KB 的段来进行一次非常小内存的重用分配，还有一个 _relative_max_cache_bad_fit_ 值，该值表示如果缓存的段大小比请求分配的段大，它们大小的差值如果大于这个百分比，那么它可能不会被使用。它默认值是20%。举例来说，当需要一个10 KB 的段时，最大可以使用一个12 KB 的段。

段缓存中的条目数默认为10，但是可以设置为 0 到 30 之间的任何值。

==== 内存分配器框架：alloc_util

在这两个通用分配器 ( sys_alloc 和 mseg_alloc ) 之上构建的是一个名为 _alloc_util_ 的框架，它用于为不同类型的用法和数据来实现特定的内存分配器。

框架是在 https://github.com/erlang/otp/blob/OTP-23.1/erts/emulator/beam/erl_alloc_util.h[_erl_alloc_util.h_] 和 https://github.com/erlang/otp/blob/OTP-23.1/erts/emulator/beam/erl_alloc_util.c[_erl_alloc_util.c_] 中实现的。ERTS 所使用的各种不同的分配器是在 https://github.com/erlang/otp/blob/OTP-23.1/erts/emulator/beam/erl_alloc.types[erl_alloc.types] 中定义的。

在SMP系统中，通常为每个调度器线程分别提供一套每种类型的分配器。

分配器可以操作的最小内存单位称为块 ( _block_ )。当您调用一个分配器来分配一定数量的内存时，得到的返回是一个块。当你希望释放内存时，块也作为参数提供给分配器。

然而，分配器并不直接从操作系统分配块。相反，分配器通过 sys_alloc 或 mseg_alloc ( 使用 malloc 或者 mmap 实现 ) 从操作系统分配一个载体 ( _carrier_ )。如果使用 sys_alloc，则载体被放在 C-堆上，如果使用 mseg_alloc，则载体被放在一个段中。

小块被放置在多块载体 ( multiblock carrier ) 中。多块载体可以像它的名字一样包含许多块。更大的块放在单块载体 ( singleblock carrier ) 中，就像他的名字意味着只包含一个块一样。

什么是小块，什么是大块是由参数 _singleblock carrier threshold_ (+sbct+) 决定的，请参阅下面的系统标志列表。

大多数分配器也有一个“主多块载体” ( main multiblock carrier )，它永远不会被释放。

[ditaa]
----
 high
 addresses
           |FREE OS MEMORY |
           +---------------+ brk
           |   FREE HEAP   |       | less than MYtt kb
           +---------------+
     /     |  Unused PAD   |  | multiple of Muycs
    |      |---------------|  |
    S      |               |  |    |
singleblock|               |  |    |
 carrier 1 |     Block     |  |    | larger than MSsbct kb
    |      |               |  |    |
     \     |               |  |    |
           +---------------+
     /     |Free in Carrier|       |
    |      |---------------|       |
    S      |               |       |
  main     |               |       |
multiblock |     Block 2   |       | MSmmbcs kb
 carrier   |---------------|       |
    |      |               |       |
     \     |     Block 1   |       |
           +---------------+
           |               |
           |    U S E D    |
           |               |
           +---------------+ start_brk
               C - Heap
 low
 addresses


----

// Want most data un multiblock carriers mbc
// increase sbct, then increase smbcs and lmbcs

===== 内存分配策略

++++
<!--
Are you intending for readers to take advantage of these allocation strategies in their code? If so, this section needs to be much more prominent, and not a subheading in a reference section.  - bmacdonald
-->

++++

内存分配策略被使用，以在多块载体中找到一个空闲的内存块。每种类型的分配器都有一个默认的分配策略，但也可以使用  +as+  标志设置它的分配策略。

Erlang 运行时系统应用程序参考手册列出了以下分配策略:

[quote,'http://www.erlang.org/doc/man/erts_alloc.html[erts_alloc]']
__________________________

_Best fit_：找到满足请求快大小要求的最小块。(bf)

_Address order best fit_：找到满足请求快大小要求的最小块。如果找到多个块，选最低地址的块。(aobf)

_Address order first fit carrier best fit_：找到能满足请求块大小的最低地址的载体，然后使用 "best fit" 策略在该载波中找到一个块。 (aoffcbf)

_Address order first fit carrier address order best fit_：找到能满足请求块大小的最低地址的载体，然后使用 "address order best fit" 策略在该载体内找到一个块。 (aoffcaobf)

_Good fit_：试着找到最适合的，但是只在有限的搜索中找到。(gf)

_A fit_: 不搜索某个合适的，只检查某空闲块看看是否它满足了要求。这个策略只是意在临时分配时被使用。(af)

__________________________



==== 临时分配器：temp_alloc

分配器 _temp_alloc_ 用于临时内存分配。这是非常短暂的分配。temp_alloc 分配的内存，生存期不能超过 Erlang 进程上下文切换。

在函数内执行某些工作时，可以使用 temp_alloc 作为一个临时工作区。把它看作是 C-stack 的扩展，并以同样的方式释放它。也就是说，为了安全起见，从执行分配的函数返回之前，需要释放通过 temp_alloc 分配的内存。在 erl_alloc.types 中有一个注释 (译注，见链接：https://github.com/erlang/otp/blob/OTP-23.1/erts/emulator/beam/erl_alloc.types#L109[erl_alloc.types])，说明在模拟器重新开始执行 Erlang 代码之前应该释放 temp_alloc 块。

注意，与分配器运行在同一调度程序上的 Erlang 进程不可能在释放块之前开始执行 Erlang 代码。这意味着您不能在 BIF 或 NIF 陷阱(yield) 上使用临时分配。

在默认的 R16 SMP 系统中，有N+1 个 temp_alloc 分配器，其中 N 是调度器的数量。temp_alloc 使用 “A fit”(af) 策略。由于 temp_alloc的分配模式基本上是栈分配模式 (大部分大小为0或1)，因此该策略可以很好地工作。

临时分配器在 R16 中用于以下类型的数据：TMP_HEAP、MSG_ROOTS、ROOTSET、LOADER_TEMP、NC_TMP、TMP、DCTRL_BUF、TMP_DIST_BUF、ESTACK、DB_TMP、DB_MC_STK、DB_MS_CMPL_HEAP、LOGGER_DSBUF、TMP_DSBUF、DDLL_TMP_BUF、TEMP_TERM、SYS_READ_BUF、ENVIRONMENT、CON_VPRINT_BUF。

有关每个分配器分配的最新分配类型列表，请参阅erl_alloc.types。( 例如：grep TEMPORARY erts/emulator/beam/erl_allocation .types )。

我不会逐一介绍这些不同的类型，但一般来说，正如通过它们的名称猜测的那样，它们是临时缓冲区或工作堆栈。

The temporary allocator is, in R16, used by the following types of
data: TMP_HEAP, MSG_ROOTS, ROOTSET, LOADER_TEMP, NC_TMP, TMP,
DCTRL_BUF, TMP_DIST_BUF, ESTACK, DB_TMP, DB_MC_STK, DB_MS_CMPL_HEAP,
LOGGER_DSBUF, TMP_DSBUF, DDLL_TMP_BUF, TEMP_TERM, SYS_READ_BUF,
ENVIRONMENT, CON_VPRINT_BUF.

For an up to date list of allocation types allocated with each
allocator, see erl_alloc.types
(e.g. +grep TEMPORARY erts/emulator/beam/erl_alloc.types+).

==== 堆分配器：eheap_alloc

堆分配器用于分配存储 tagged Erlang 项式的内存块，如 Erlang 进程堆(所有代)、堆碎片和 beam_registers。

这可能是您作为 Erlang 开发人员或调优 Erlang 系统时最感兴趣的内存区域。在后面关于垃圾收集和进程内存的部分中，我们将更多地讨论如何管理这些区域。在这里，我们还将介绍什么是堆片段。

==== 二进制数据分配器：binary_alloc

你猜对了，二进制数据 (Binary) 分配器用于分配二进制类型的项式。二进制数据可以有相当不同的大小和不同的生命周期。默认情况下，这个分配器使用  _best fit_  分配策略。

==== ETS 分配器：ets_alloc

ETS 分配器用于大多数 ETS 相关的数据，除了一些短生存期 ( short lived ) 项式或 ETS 表使用的临时数据

==== 驱动 (Driver) 分配器：driver_alloc

驱动分配器用于端口，内联驱动 ( linked in driver ) 和NIF。

==== 短生存期分配器：sl_alloc

短生存期分配器用于预期短生存期的列表和缓冲区。短生存期数据的寿命可能比临时数据长。

// alloc_info_request async bif_timer_sl binary_buffer busy_caller
// busy_caller_table code_ix_lock_q db_fixation db_match_spec_run_heap
// db_proc_cleanup_state ethread_short_lived external_term_data
// extra_port_list extra_root fd_list fixed_del gc_info_request
// misc_aux_work misc_op_list pending_suspend pollset_update_req
// port_names port_task port_task_handle_list prepared_code proc_list
// ptab_list_chunk_info ptab_list_deleted_el ptab_list_pids ptimer_sl
// re_stack re_subject sched_wall_time_request short_lived_thr_queue
// sl_migration_paths ssb system_messages_queue temp_thr_prgr_data
// tmp_cpu_ids unicode_buffer

==== 长生存期分配器：ll_alloc

长生存期分配程序用于长生存期数据，如原子、模块、fun 和长生存期表

// atom_entry atom_tab atom_text aux_work_timeouts bif_timer_table code
// code cpu_data cpu_groups_map cs_prog_path db_match_pseudo_proc
// db_match_pseudo_proc db_tabs ddll_errcodes driver_event_state drv_tab
// ethread_long_lived export_entry export_entry export_tab fd_status
// fd_tab fp_exception fun_entry instr_info internal_async_data
// ll_migration_paths ll_temp_term ll_temp_term long_lived_thr_queue
// misc_aux_work_q module_entry module_tab poll_fds poll_result_events
// pollset port_tab pre_alloc_data preloaded proc_lock_waiter proc_tab
// process_interval run_queue_balancing run_queues scheduler_data
// scheduler_data scheduler_sleep_info select_fds taint_list
// thr_prgr_data thr_prgr_internal_data timer_wheel waiter_object

==== 定长分配器：fix_alloc

定长分配器用于固定大小的对象，如 PCB、消息引用和其他一些对象。固定大小分配器默认使用 _address order best fit_ 分配策略。

// driver_event_data_state driver_select_data_state monitor_sh msg_ref
// nlink_sh proc sl_thr_q_element

==== 标准分配器：std_alloc

其他类型的数据使用标准分配器。( active_procs alloc_info_request arg_reg bif_timer_ll bits_buf bpd calls_buf db_heir_data db_heir_data db_named_table_entry dcache ddll_handle ddll_processes ddll_processes dist_entry dist_tab driver_lock ethread_standard fd_entry_buf fun_tab gc_info_request io_queue line_buf link_lh module_refs monitor_lh monitor_lh monitor_sh
nlink_lh nlink_lh nlink_sh node_entry node_tab nodes_monitor port_data_heap port_lock port_report_exit port_specific_data proc_dict process_specific_data ptimer_ll re_heap reg_proc reg_tab sched_wall_time_request stack suspend_monitor thr_q_element thr_queue zlib )

=== system flags for memory（原书未完成）

原书未完成

=== 进程内存

正如我们在 xref:CH-Processes[] 中看到的那样，进程实际上只是一些内存区域，在本章中，我们将更深入地研究如何管理栈、堆和邮箱。

栈和堆的默认大小是 233 个字。在启动 Erlang 时，可以通过 +pass:[+h]+ 标志对默认大小进行全局更改。在使用 +spawn_opt+ 启动进程时，还可以通过设置 +min_heap_size+ 来设置最小堆大小。

正如我们在 xref:CH-TypeSystem[] 中看到的那样，Erlang 项式都是被标记的，当它们存储在堆上时，它们要么是 cons 单元 ( 列表单元 ) ，要么是装箱对象。

==== 项式共享

堆上的对象在一个进程的上下文中通过引用传递。如果使用元组作为参数调用一个函数，那么只有对该元组的标记引用传递给被调用的函数。在构建新项式时，将只使用对子项式的引用。

例如，如果你有字符串 “hello” (它与这个整数列表相同：[104,101,108,108,111])，你会得到一个类似于:


[[fig-list_layout]]
[ditaa]
----
         ADR                               BINARY  VALUE  +  DESCRIPTION
 hend ->     +-------- -------- -------- --------+
             |              ...                  |
             |              ...                  |
             |00000000 00000000 00000000 10000001| 128 + list tag  ---------------+
 stop ->     |                                   |                                |
                                                                                  |
 htop ->     |                                   |                                |
         132 |00000000 00000000 00000000 01111001| 120 + list tag  -------------- | -+
         128 |00000000 00000000 00000110 10001111| (h) 104 bsl 4 + small int tag <+  |
         124 |00000000 00000000 00000000 01110001| 112 + list tag  ----------------- | -+
         120 |00000000 00000000 00000110 01011111| (e) 101 bsl 4 + small int tag <---+  |
         116 |00000000 00000000 00000000 01110001| 112 + list tag  -------------------- | -+
         112 |00000000 00000000 00000110 11001111| (l) 108 bsl 4 + small int tag <------+  |
         108 |00000000 00000000 00000000 01110001|  96 + list tag  ----------------------- | -+
         104 |00000000 00000000 00000110 11001111| (l) 108 bsl 4 + small int tag <---------+  |
         100 |11111111 11111111 11111111 11111011| NIL                                        |
          96 |00000000 00000000 00000110 11111111| (o) 111 bsl 4 + small int tag <------------+
             |                ...                |
 heap ->     +-----------------------------------+


----

如果您随后创建了一个包含两个列表实例的元组，那么重复的内容就是指向该列表的带标签的指针：00000000000000000000000001000001。代码

----
L = [104, 101, 108, 108, 111],
T = {L, L}.
----

将导致如下所示的内存布局。也就是说，一个装箱头表示这是一个大小为 2 的元组，然后是两个指向同一个列表的指针。

----
ADR VALUE                            DESCRIPTION
144 00000000000000000000000001000001 128+CONS
140 00000000000000000000000001000001 128+CONS
136 00000000000000000000000010000000 2+ARITYVAL
----

这样做很好，因为这样做很节省，而且只占用很少的空间。但如果您将元组发送到另一个进程或执行任何其他类型的IO，或任何导致所谓深拷贝 ( _deep copy_) 的操作，则数据结构将被扩展。因此，如果我们将元组 +T+ 发送到另一个进程 P2 ( +pass:[P2 ! T]+ ) 则 T2 的堆为:

----
 .. TODO
----

通过扩展高度共享的项式，可以很快使 Erlang 节点宕机，请参阅 <<listing-share,share.erl>>。

[source,erlang]
----
-module(share).

-export([share/2, size/0]).

share(0, Y) -> {Y,Y};
share(N, Y) -> [share(N-1, [N|Y]) || _ <- Y].

size() ->
    T = share:share(5,[a,b,c]),
    {{size, erts_debug:size(T)},
     {flat_size, erts_debug:flat_size(T)}}.



 1> timer:tc(fun() -> share:share(10,[a,b,c]), ok end).
 {1131,ok}

 2> share:share(10,[a,b,c]), ok.
 ok

 3> byte_size(list_to_binary(test:share(10,[a,b,c]))), ok.
 HUGE size (13695500364)
 Abort trap: 6

----

可以使用函数 +erts_debug:size/1+ 和 +erts_debug:flat_size/1+ 计算共享项式的内存大小和项式的扩展大小。

[source,erlang]
----
> share:size().
{{size,19386},{flat_size,94110}}

----

对于大多数应用程序来说，这不是问题，但是您应该意识到这个问题，它可能在许多情况下出现。深拷贝用于 IO、ETS 表、binary_to_term 和 消息传递。

让我们更详细地了解消息传递是如何工作的。

==== 消息传递

当进程 P1 向另一个 (本地) 进程 P2 发送消息 M 时，进程 P1 首先计算 M 的扩展大小，然后通过在本地调度器上下文中对 heap_frag 执行 heap_alloc 来分配该大小的新消息缓冲区。

给出 <<listing-send,send.erl>> 中的代码。在 p1/1 send 之前，系统的状态可能是这样的：


[ditaa]
----

    x0       |00000000 00000000 00000000 00100011| Pid 2
    x1       |00000000 00000000 00000000 01001010| 136 + boxed tag -----------+
                                                                              |
                                                                              |
         ADR                               BINARY  VALUE  +  DESCRIPTION      |
 hend ->     +-------- -------- -------- --------+                            |
             |              ...                  |                            |
             |              ...                  |                            |
 stop ->     |                                   |                            |
                                                                              |
 htop ->     |                                   |                            |
         144 |00000000 00000000 00000000 01000001| 128+CONS        ---------------+
         140 |00000000 00000000 00000000 01000001| 128+CONS        ---------------+
         136 |00000000 00000000 00000000 10000000| 2+ARITYVAL             <---+   |
         132 |00000000 00000000 00000000 01111001| 120+CONS        -------------- | -+
         128 |00000000 00000000 00000110 10001111| (h) 104 bsl 4 + small int tag <+  |
         124 |00000000 00000000 00000000 01110001| 112+CONS        ----------------- | -+
         120 |00000000 00000000 00000110 01011111| (e) 101 bsl 4 + small int tag <---+  |
         116 |00000000 00000000 00000000 01110001| 112+CONS        -------------------- | -+
         112 |00000000 00000000 00000110 11001111| (l) 108 bsl 4 + small int tag <------+  |
         108 |00000000 00000000 00000000 01110001|  96+CONS        ----------------------- | -+
         104 |00000000 00000000 00000110 11001111| (l) 108 bsl 4 + small int tag <---------+  |
         100 |11111111 11111111 11111111 11111011| NIL                                        |
          96 |00000000 00000000 00000110 11111111| (o) 111 bsl 4 + small int tag <------------+
             |                ...                |
 heap ->     +-----------------------------------+


P2


----

然后 P1 开始向 P2 发送消息 M。它 (通过 erl_message.c 中的代码) 首先计算 M (在我们的示例中是 23 个字长) footnote:[在这里，我们忽略 tracing，它会在消息大小上增加跟踪标记的空间，并且会使用堆片段] 的平面大小。然后(在SMP系统中)，如果它可以锁定 P2，并且 P2 的堆中有足够的空间，它就会将消息复制到 P2 的堆中。

如果 P2 正在运行 (或退出) 或者堆上没有足够的空间，那么分配一个新的堆片段 (大小为：sizeof ErlHeapFragment - sizeof(Eterm) + 23*sizeof(Eterm)) footnote:[减去一个 sizeof(Eterm) 的原因是，ErlHeapFragment 的内存中已经包含了一个 Eterm 的大小]，初始化后的样子是：

----
erl_heap_fragment:
    ErlHeapFragment* next;	  NULL
    ErlOffHeap off_heap:
      erl_off_heap_header* first; NULL
      Uint64 overhead;               0
    unsigned alloc_size;	    23
    unsigned used_size;             23
    Eterm mem[1];		     ?
      ... 22 free words
----

然后，消息被复制到堆片段中：

----
erl_heap_fragment:
    ErlHeapFragment* next;	  NULL
    ErlOffHeap off_heap:
      erl_off_heap_header* first; Boxed tag+&amp;mem+2*WS-+
      Uint64 overhead;               0                |
    unsigned alloc_size;	    23                |
    unsigned used_size;             23                |
    Eterm mem:                    2+ARITYVAL   <------+
                                  &amp;mem+3*WS+1  ---+
                                  &amp;mem+13*WS+1 ------+
                                  (H*16)+15    <--+  |
                                  &amp;mem+5*WS+1  --+   |
                                  (e*16)+15    <-+   |
                                  &amp;mem+7*WS+1  ----| |
                                  (l*16)+15    <---+ |
                                  &amp;mem+9*WS+1  ---+  |
                                  (l*16)+15    <--+  |
                                  &amp;mem+11*WS+1 ----+ |
                                  (o*16)+15    <---+ |
                                  NIL                |
                                  (H*16)+15    <-----+
                                  &amp;mem+15*WS+1 --+
                                  (e*16)+15    <-+
                                  &amp;mem+17*WS+1 ----|
                                  (l*16)+15    <---+
                                  &amp;mem+19*WS+1 ---+
                                  (l*16)+15    <--+
                                  &amp;mem+21*WS+1 ----+
                                  (o*16)+15    <---+
                                  NIL
----

在这两种情况下，都分配了一个新的mbox (+ErlMessage+)，接收端加一个锁 (+ERTS_PROC_LOCK_MSGQ+)，堆上或新堆片段中的消息链接到 mbox 中。

----
 erl_mesg {
    struct erl_mesg* next = NULL;
    data:  ErlHeapFragment *heap_frag = bp;
    Eterm m[0]            = message;
 } ErlMessage;

----

然后 mbox 被链接到接收方的 in message queue (+msg_inq+) 中，锁被释放。注意 +msg_inq.last+ 指向队列中最后一条消息的 +next+ 字段。当一个新的 mbox 被链接时，下一个指针被更新为指向新的 mbox，最后一个指针被更新为指向新的 mbox 的 next 字段。

[[SS-Binaries]]
==== 二进制数据

正如我们在 xref:CH-TypeSystem[] 中看到的，在内部有四种类型的二进制文件。其中三种类型，_heap binaries_, _sub binaries_ 和 _match contexts_ 存储在本地堆上，由垃圾收集器处理，并像任何其他对象一样作为消息传递，并根据需要复制。

===== 引用计数

另一方面，大型二进制数据或 _refc binaries_ (译注：reference-counted binaries 的缩写) 部分存储在进程堆之外，并被引用计数。_refc binaries_ 是第四种二进制类型。

refc binary 的有效载荷存储在二进制分配器分配的内存中。还有一个叫 ProcBin 的，对 refc binary 的有效负载的小引用存储在进程堆上。该引用可能会由消息传递或 GC 复制，但载荷并不会被复制。因为不需要复制整个二进制数据，使得向其他进程发送大型二进制数据变得相对节省。

通过 ProcBin 对 refc binary 的每次引用都会使该二进制数据的引用计数增加 1。进程堆上的所有 ProcBin 对象都链接在一个链表中。在一次 GC 之后，这个链表被遍历，堆外二进制数据的引用计数会减少，每个将被回收的引用 refc binary 的 ProcBin 都会导致该 refc binary 减少一个引用计数。如果 refc binary 的引用计数减到 0，该二进制数据所占内存将被释放。

对大型二进制数据进行引用计数，并且不在消息发送或垃圾收集时复制数据是一个很大的成功，但是在垃圾收集和引用计数混合的环境中存在一个问题。在纯引用计数实现中，一旦对对象的引用终止，引用计数就会减少，当引用计数减到 0 时，对象就会被释放。在 ERTS 混合环境中，直到垃圾收集检测到该引用已死前，对引用计数对象的引用都不会终止。

这意味着在所有对二进制数据的引用都停止后，二进制数据 (往往很大，甚至非常巨大) 可能会挂起很长一段时间。注意，由于二进制数据是全局分配的，所以来自所有进程的所有引用都必须是死的，也就是说，所有看到二进制数据的进程都需要进行GC。

不幸的是，作为开发人员，要知道哪些进程看到了二进制数据并不总是那么容易。例如，假设您有一个负载均衡器，它接收工作项并将它们分派给 worker。

在 <<load_balancer,this code>> 中，有一个不需要执行GC的循环示例。(参见清单  <<listing-lb,listing lb>>  获得完整示例。)

[[load_balancer]]
----
loop(Workers, N) ->
  receive
    WorkItem ->
       Worker = lists:nth(N+1, Workers),
       Worker ! WorkItem,
       loop(Workers, (N+1) rem length(Workers)) 
  end.
----

这个服务器只会持续抓取对二进制数据的引用，并且永远不会释放它们，最终会耗尽所有系统内存。

当意识到这个问题时，发现其实它很容易解决：可以在每次 _循环_ 迭代时执行一个 garbage_collect，或者通过在 receive 中添加一个 after 子句，每隔5秒执行一次。 ( _after 5000 -> garbage_collect(), loop(Workers, N)_ )

译注：关于二进制数据的更多信息，可以参考文档 link:http://erlang.org/doc/efficiency_guide/binaryhandling.html[binaryhandling]。

===== Sub Binaries 以及匹配

当你匹配二进制数据的一部分，你会得到一个 sub binary。sub binary 是一个小的结构，只包含指向真正二进制数据的指针。这增加了二进制文件的引用计数，但只使用很少的额外空间。

如果一次匹配，需要创建二进制数据中已匹配部分的新副本，就会既消耗空间又消耗时间。所以在大多数情况下，对二进制数据进行模式匹配然后使用 sub binary ，就是你想要的。

有一些退化的情况，想象一下你把像书这样的大文件加载到内存中，然后你匹配一个小的部分，比如一章。问题是书的其余部分仍然保存在内存中，直到你处理完这一章。如果你对许多书都这样做，也许你希望在文件系统中获得每本书的介绍，你可能将把每本书的整个内容保存在内存中，而不仅仅是介绍性章节。这可能会导致大量内存的使用。

在这种情况下，当你知道你只需要一个大二进制文件的一小部分，并且您想让这一小部分保留一段时间时，解决方案是使用 `binary:copy/1`。这个函数只使用其副作用，从实际二进制文件中复制 sub binary，删除对更大二进制数据的引用，从而有希望对其进行垃圾收集。

在 Erlang 文档中有关于如何构造和匹配二进制文件的详细解释： link:http://erlang.org/doc/efficiency_guide/binaryhandling.html[binaryhandling]。

==== 垃圾收集

++++
<!--
This part of the content seems to be good, and probably worthy of being a top-level heading. It might be a bit long, though. - bmacdonald
-->
++++

当进程用完堆栈上的空间并堆起来时，进程将尝试通过执行一次 minor GC 来回收空间。此代码可以在 https://github.com/erlang/otp/blob/maint/erts/emulator/beam/erl_gc.c[erl_gc.c] 中找到。

ERTS使用分代复制垃圾收集器。复制收集器意味着在垃圾收集期间，所有活的年轻项式都从旧堆复制到新堆。然后旧堆被丢弃。分代收集器的工作原理是大多数项式在年轻时就消失了，它们是创建、使用和丢弃的临时项式。旧的项式被提升到很少收集的老一代，理性地说，一旦一个术语变老了，它可能会活很长一段时间。

从概念上讲，垃圾收集周期的工作原理如下:

* 首先收集所有根(例如栈)。
* 然后，对于每个根，如果根指向没有转发指针的堆分配对象，则将该对象复制到新堆。对于每个复制的对象，用一个指向新副本的转发指针更新原始对象。
* 现在遍历新堆并执行与根堆相同的操作。

我们将通过一个示例来详细了解这是如何实现的。我们将在不使用旧代的情况下进行 minor GC，并且只使用栈作为根集。实际上，进程字典、跟踪数据 ( trace data ) 和探测数据 ( probe data ) 等也包含在根集中。

让我们看看在 gc_example 中调用 garbage_collect 的行为。代码将生成一个由 cons 和元组的两个元素共享的字符串，元组将被消除，从而产生垃圾。GC 之后，堆上应该只有一个字符串。也就是说，首先生成项式 +{["Hello","Hello"], "Hello"}+ (在所有实例中共享相同的字符串"Hello")。然后在触发 GC 时只保留项式  +["Hello","Hello"]+ 。

NOTE: 我们将借此机会介绍如何在 linux 系统上使用 gdb 检查 ERTS 的行为。当然，您可以使用自己选择的调试器。如果你已经知道如何使用 gdb，或者如果你对调试器没有兴趣，你可以忽略关于如何检查系统的元文本，而只是看看图表和关于 GC 如何工作的解释。


[source,erlang]
----
include::../code/memory_chapter/src/gc_example.erl[]
----

编译示例后，我启动了一个 erlang shell，测试调用并准备对示例进行新的调用 (不按下return键):

----
1> gc_example:example().
["Hello","Hello"]
2> spawn(gc_example,example,[]).
----

然后使用 gdb 连接到 erlang 节点(本例中 OS PID: 2955)
----
$ gdb /home/happi/otp/lib/erlang/erts-6.0/bin/beam.smp 2955
----


NOTE: 根据你对 ptrace_scope 的设置，你可能必须在 gdb 调用之时使用 sudo。

然后在 gdb 中，我在主 GC 函数的开始处设置了一个断点，然后让节点继续:

----
(gdb) break garbage_collect_0
(gdb) cont
Continuing.
----

现在我在 Erlang shell 中按回车键，执行在断点处停止:

----
Breakpoint 1, garbage_collect_0 (A__p=0x7f673d085f88, BIF__ARGS=0x7f673da90340) at beam/bif.c:3771
3771	    FLAGS(BIF_P) |= F_NEED_FULLSWEEP;
----

现在我们可以检查进程的PCB：

----
(gdb) p *(Process *) A__p
$1 = {common = {id = 1408749273747, refc = {counter = 1}, tracer_proc = 18446744073709551611, trace_flags = 0, u = {alive = {
        started_interval = 0, reg = 0x0, links = 0x0, monitors = 0x0, ptimer = 0x0}, release = {later = 0, func = 0x0, data = 0x0, 
        next = 0x0}}}, htop = 0x7f6737145950, stop = 0x7f6737146000, heap = 0x7f67371458c8, hend = 0x7f6737146010, heap_sz = 233, 
  min_heap_size = 233, min_vheap_size = 46422, fp_exception = 0, hipe = {nsp = 0x0, nstack = 0x0, nstend = 0x0, ncallee = 0x7f673d080000, 
    closure = 0, nstgraylim = 0x0, nstblacklim = 0x0, ngra = 0x0, ncsp = 0x7f673d0863e8, narity = 0, float_result = 0}, arity = 0, 
  arg_reg = 0x7f673d086080, max_arg_reg = 6, def_arg_reg = {393227, 457419, 18446744073709551611, 233, 46422, 2000}, cp = 0x7f673686ac40, 
  i = 0x7f673be17748, catches = 0, fcalls = 1994, rcount = 0, schedule_count = 0, reds = 0, group_leader = 893353197987, flags = 0, 
  fvalue = 18446744073709551611, freason = 0, ftrace = 18446744073709551611, next = 0x7f673d084cc0, nodes_monitors = 0x0, 
  suspend_monitors = 0x0, msg = {first = 0x0, last = 0x7f673d086120, save = 0x7f673d086120, len = 0, mark = 0x0, saved_last = 0x7d0}, u = {
    bif_timers = 0x0, terminate = 0x0}, dictionary = 0x0, seq_trace_clock = 0, seq_trace_lastcnt = 0, 
  seq_trace_token = 18446744073709551611, initial = {393227, 457419, 0}, current = 0x7f673be17730, parent = 1133871366675, 
  approx_started = 1407857804, high_water = 0x7f67371458c8, old_hend = 0x0, old_htop = 0x0, old_heap = 0x0, gen_gcs = 0, 
  max_gen_gcs = 65535, off_heap = {first = 0x0, overhead = 0}, mbuf = 0x0, mbuf_sz = 0, psd = 0x0, bin_vheap_sz = 46422, 
  bin_vheap_mature = 0, bin_old_vheap_sz = 46422, bin_old_vheap = 0, sys_task_qs = 0x0, state = {counter = 41002}, msg_inq = {first = 0x0, 
    last = 0x7f673d086228, len = 0}, pending_exit = {reason = 0, bp = 0x0}, lock = {flags = {counter = 1}, queue = {0x0, 0x0, 0x0, 0x0}, 
    refc = {counter = 1}}, scheduler_data = 0x7f673bd6c080, suspendee = 18446744073709551611, pending_suspenders = 0x0, run_queue = {
    counter = 140081362118912}, hipe_smp = {have_receive_locks = 0}}
----

哇，信息量真大啊。有趣的部分是关于栈和堆:

----
hend = 0x7f6737146010,
stop = 0x7f6737146000,
htop = 0x7f6737145950,
heap = 0x7f67371458c8,
----

通过使用一些 helper 脚本，我们可以以一种有意义的方式检查栈和堆。(gdb_script 中的脚本定义见 xref:AP-listings[] 。)

----
(gdb) source gdb_scripts 
(gdb) print_p_stack A__p
0x00007f6737146008 [0x00007f6737145929] cons -> 0x00007f6737145928
(gdb) print_p_heap A__p
0x00007f6737145948 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145940 [0x00007f6737145929] cons -> 0x00007f6737145928
0x00007f6737145938 [0x0000000000000080] Tuple size 2
0x00007f6737145930 [0x00007f6737145919] cons -> 0x00007f6737145918
0x00007f6737145928 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145920 [0xfffffffffffffffb] NIL
0x00007f6737145918 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145910 [0x00007f67371458f9] cons -> 0x00007f67371458f8
0x00007f6737145908 [0x000000000000048f] 72
0x00007f6737145900 [0x00007f67371458e9] cons -> 0x00007f67371458e8
0x00007f67371458f8 [0x000000000000065f] 101
0x00007f67371458f0 [0x00007f67371458d9] cons -> 0x00007f67371458d8
0x00007f67371458e8 [0x00000000000006cf] 108
0x00007f67371458e0 [0x00007f67371458c9] cons -> 0x00007f67371458c8
0x00007f67371458d8 [0x00000000000006cf] 108
0x00007f67371458d0 [0xfffffffffffffffb] NIL
0x00007f67371458c8 [0x00000000000006ff] 111
----

在这里，我们可以看到进程在堆上分配列表 “Hello” 和两次包含该列表的 cons，以及包含 cons 和列表的元组之后的堆。根集 (在本例中是栈) 包含一个指向 cons 的指针，cons 包含列表的两个副本。元组是死的，也就是说，没有对它的引用。

垃圾收集从计算根集和分配新堆开始。通过在调试器中进入GC代码，您可以看到这是如何完成的。这里不继续深入。在执行许多步骤之后，会到达根集中的所有项式都被复制到新堆的位置。这是从 erl_gc.c 中的 +while+ 循环(取决于版本)第 1272 行开始的。

在我们的例子中，根是一个列表项，指向地址0x00007f95666597f0 包含字母 (整数) h。列表项被从当前堆 (from space)，移动到目标空间 (to space)，列表头的值被一个  _moved cons_ tag (值为0) 覆写。

在移动根集的第一步之后，from space和to space看起来是这样的：

from space:

----
(gdb) print_p_heap p
0x00007f6737145948 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145940 [0x00007f6737145929] cons -> 0x00007f6737145928
0x00007f6737145938 [0x0000000000000080] Tuple size 2
0x00007f6737145930 [0x00007f67371445b1] cons -> 0x00007f67371445b0
0x00007f6737145928 [0x0000000000000000] Tuple size 0
0x00007f6737145920 [0xfffffffffffffffb] NIL
0x00007f6737145918 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145910 [0x00007f67371458f9] cons -> 0x00007f67371458f8
0x00007f6737145908 [0x000000000000048f] 72
0x00007f6737145900 [0x00007f67371458e9] cons -> 0x00007f67371458e8
0x00007f67371458f8 [0x000000000000065f] 101
0x00007f67371458f0 [0x00007f67371458d9] cons -> 0x00007f67371458d8
0x00007f67371458e8 [0x00000000000006cf] 108
0x00007f67371458e0 [0x00007f67371458c9] cons -> 0x00007f67371458c8
0x00007f67371458d8 [0x00000000000006cf] 108
0x00007f67371458d0 [0xfffffffffffffffb] NIL
0x00007f67371458c8 [0x00000000000006ff] 111
----

to space:

----
(gdb) print_heap n_htop-1 n_htop-2
0x00007f67371445b8 [0x00007f6737145919] cons -> 0x00007f6737145918
0x00007f67371445b0 [0x00007f6737145909] cons -> 0x00007f6737145908

----

在  _from space_ 中，第一个列表项的头部被 0 覆盖 (看起来像一个大小为 0 的元组)，尾部被一个指向 _to space_ 中新的列表项的转发指针覆盖。在 to space 中，我们现在有了第一个列表项，它有两个反向指针指向 from space 中列表项的头和尾。

当收集器处理完根集时，to space 包含指向所有仍然活动的项式的向后指针。此时，收集器开始扫 _to space_。它使用两个指针 +n_hp+ 指向不可见的堆的底部， +n_htop+ 指向堆的顶部。

----
n_htop:
        0x00007f67371445b8 [0x00007f6737145919] cons -> 0x00007f6737145918
n_hp    0x00007f67371445b0 [0x00007f6737145909] cons -> 0x00007f6737145908
----

然后 GC 将查看 +n_hp+ 指向的值，在本例中是指回 _from space_ 的列表项。因此，它将该列表项移到 to space 中，递增 n_htop 为新的列表项腾出空间，递增 +n_hp+ 表示第一个列表项可见。

----
from space:

0x00007f6737145948 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145940 [0x00007f6737145929] cons -> 0x00007f6737145928
0x00007f6737145938 [0x0000000000000080] Tuple size 2
0x00007f6737145930 [0x00007f67371445b1] cons -> 0x00007f67371445b0
0x00007f6737145928 [0x0000000000000000] Tuple size 0
0x00007f6737145920 [0xfffffffffffffffb] NIL
0x00007f6737145918 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145910 [0x00007f67371445c1] cons -> 0x00007f67371445c0
0x00007f6737145908 [0x0000000000000000] Tuple size 0
0x00007f6737145900 [0x00007f67371458e9] cons -> 0x00007f67371458e8
0x00007f67371458f8 [0x000000000000065f] 101
0x00007f67371458f0 [0x00007f67371458d9] cons -> 0x00007f67371458d8
0x00007f67371458e8 [0x00000000000006cf] 108
0x00007f67371458e0 [0x00007f67371458c9] cons -> 0x00007f67371458c8
0x00007f67371458d8 [0x00000000000006cf] 108
0x00007f67371458d0 [0xfffffffffffffffb] NIL
0x00007f67371458c8 [0x00000000000006ff] 111

to space:

n_htop:
        0x00007f67371445c8 [0x00007f67371458f9] cons -> 0x00007f67371458f8
        0x00007f67371445c0 [0x000000000000048f] 72
n_hp    0x00007f67371445b8 [0x00007f6737145919] cons -> 0x00007f6737145918
SEEN    0x00007f67371445b0 [0x00007f67371445c1] cons -> 0x00007f67371445c0
----

同样的事情也会发生在第列表项上。

----
from space:

0x00007f6737145948 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145940 [0x00007f6737145929] cons -> 0x00007f6737145928
0x00007f6737145938 [0x0000000000000080] Tuple size 2
0x00007f6737145930 [0x00007f67371445b1] cons -> 0x00007f67371445b0
0x00007f6737145928 [0x0000000000000000] Tuple size 0
0x00007f6737145920 [0x00007f67371445d1] cons -> 0x00007f67371445d0
0x00007f6737145918 [0x0000000000000000] Tuple size 0
0x00007f6737145910 [0x00007f67371445c1] cons -> 0x00007f67371445c0
0x00007f6737145908 [0x0000000000000000] Tuple size 0
0x00007f6737145900 [0x00007f67371458e9] cons -> 0x00007f67371458e8
0x00007f67371458f8 [0x000000000000065f] 101
0x00007f67371458f0 [0x00007f67371458d9] cons -> 0x00007f67371458d8
0x00007f67371458e8 [0x00000000000006cf] 108
0x00007f67371458e0 [0x00007f67371458c9] cons -> 0x00007f67371458c8
0x00007f67371458d8 [0x00000000000006cf] 108
0x00007f67371458d0 [0xfffffffffffffffb] NIL
0x00007f67371458c8 [0x00000000000006ff] 111

to space:

n_htop:
        0x00007f67371445d8 [0xfffffffffffffffb] NIL
        0x00007f67371445d0 [0x00007f6737145909] cons -> 0x00007f6737145908
        0x00007f67371445c8 [0x00007f67371458f9] cons -> 0x00007f67371458f8
n_hp    0x00007f67371445c0 [0x000000000000048f] 72
SEEN    0x00007f67371445b8 [0x00007f6737145919] cons -> 0x00007f67371445d0
SEEN    0x00007f67371445b0 [0x00007f67371445c1] cons -> 0x00007f67371445c0
----

 _to space_ 中的下一个元素是直接的72，它只被单步跳过 (使用 n_hp++)。然后还有另一个被移走的列表项。

同样的事情也会发生在第二个列表项上。

----
from space:

0x00007f6737145948 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145940 [0x00007f6737145929] cons -> 0x00007f6737145928
0x00007f6737145938 [0x0000000000000080] Tuple size 2
0x00007f6737145930 [0x00007f67371445b1] cons -> 0x00007f67371445b0
0x00007f6737145928 [0x0000000000000000] Tuple size 0
0x00007f6737145920 [0x00007f67371445d1] cons -> 0x00007f67371445d0
0x00007f6737145918 [0x0000000000000000] Tuple size 0
0x00007f6737145910 [0x00007f67371445c1] cons -> 0x00007f67371445c0
0x00007f6737145908 [0x0000000000000000] Tuple size 0
0x00007f6737145900 [0x00007f67371445e1] cons -> 0x00007f67371445e0
0x00007f67371458f8 [0x0000000000000000] Tuple size 0
0x00007f67371458f0 [0x00007f67371458d9] cons -> 0x00007f67371458d8
0x00007f67371458e8 [0x00000000000006cf] 108
0x00007f67371458e0 [0x00007f67371458c9] cons -> 0x00007f67371458c8
0x00007f67371458d8 [0x00000000000006cf] 108
0x00007f67371458d0 [0xfffffffffffffffb] NIL
0x00007f67371458c8 [0x00000000000006ff] 111

to space:

n_htop:
        0x00007f67371445e8 [0x00007f67371458e9] cons -> 0x00007f67371458e8
        0x00007f67371445e0 [0x000000000000065f] 101
        0x00007f67371445d8 [0xfffffffffffffffb] NIL
n_hp    0x00007f67371445d0 [0x00007f6737145909] cons -> 0x00007f6737145908
SEEN    0x00007f67371445c8 [0x00007f67371458f9] cons -> 0x00007f67371445e0
SEEN    0x00007f67371445c0 [0x000000000000048f] 72
SEEN    0x00007f67371445b8 [0x00007f6737145919] cons -> 0x00007f67371445d0
SEEN    0x00007f67371445b0 [0x00007f67371445c1] cons -> 0x00007f67371445c0
----

现在我们来看一个指向已经被移动的项的问题。GC 在 0x00007f6737145908 处看到 IS_MOVED_CONS 标记，并从尾部复制已被移动单元的目的地 (`*n_hp++ = ptr[1];`)。这种方式在 GC 期间保留了共享。此步骤不影响 _from space_，但 to space 中的反向指针将被重写。

----
to space:

n_htop:
        0x00007f67371445e8 [0x00007f67371458e9] cons -> 0x00007f67371458e8
        0x00007f67371445e0 [0x000000000000065f] 101
n_hp    0x00007f67371445d8 [0xfffffffffffffffb] NIL
SEEN    0x00007f67371445d0 [0x00007f67371445c1] cons -> 0x00007f67371445c0
SEEN    0x00007f67371445c8 [0x00007f67371458f9] cons -> 0x00007f67371445e0
SEEN    0x00007f67371445c0 [0x000000000000048f] 72
SEEN    0x00007f67371445b8 [0x00007f6737145919] cons -> 0x00007f67371445d0

SEEN    0x00007f67371445b0 [0x00007f67371445c1] cons -> 0x00007f67371445c0
----

然后，列表 (字符串) 的其余部分被移动。

----
from space:

0x00007f6737145948 [0x00007f6737145909] cons -> 0x00007f6737145908
0x00007f6737145940 [0x00007f6737145929] cons -> 0x00007f6737145928
0x00007f6737145938 [0x0000000000000080] Tuple size 2
0x00007f6737145930 [0x00007f67371445b1] cons -> 0x00007f67371445b0
0x00007f6737145928 [0x0000000000000000] Tuple size 0
0x00007f6737145920 [0x00007f67371445d1] cons -> 0x00007f67371445d0
0x00007f6737145918 [0x0000000000000000] Tuple size 0
0x00007f6737145910 [0x00007f67371445c1] cons -> 0x00007f67371445c0
0x00007f6737145908 [0x0000000000000000] Tuple size 0
0x00007f6737145900 [0x00007f67371445e1] cons -> 0x00007f67371445e0
0x00007f67371458f8 [0x0000000000000000] Tuple size 0
0x00007f67371458f0 [0x00007f67371445f1] cons -> 0x00007f67371445f0
0x00007f67371458e8 [0x0000000000000000] Tuple size 0
0x00007f67371458e0 [0x00007f6737144601] cons -> 0x00007f6737144600
0x00007f67371458d8 [0x0000000000000000] Tuple size 0
0x00007f67371458d0 [0x00007f6737144611] cons -> 0x00007f6737144610
0x00007f67371458c8 [0x0000000000000000] Tuple size 0

to space:

n_htop:
n_hp
SEEN    0x00007f6737144618 [0xfffffffffffffffb] NIL
SEEN    0x00007f6737144610 [0x00000000000006ff] 111
SEEN    0x00007f6737144608 [0x00007f6737144611] cons -> 0x00007f6737144610
SEEN    0x00007f6737144600 [0x00000000000006cf] 108
SEEN    0x00007f67371445f8 [0x00007f6737144601] cons -> 0x00007f6737144600
SEEN    0x00007f67371445f0 [0x00000000000006cf] 108
SEEN    0x00007f67371445e8 [0x00007f67371445f1] cons -> 0x00007f67371445f0
SEEN    0x00007f67371445e0 [0x000000000000065f] 101
SEEN    0x00007f67371445d8 [0xfffffffffffffffb] NIL
SEEN    0x00007f67371445d0 [0x00007f67371445c1] cons -> 0x00007f67371445c0
SEEN    0x00007f67371445c8 [0x00007f67371445e1] cons -> 0x00007f67371445e0
SEEN    0x00007f67371445c0 [0x000000000000048f] 72
SEEN    0x00007f67371445b8 [0x00007f67371445d1] cons -> 0x00007f67371445d0
SEEN    0x00007f67371445b0 [0x00007f67371445c1] cons -> 0x00007f67371445c0
----

这个例子中有一些需要注意的地方。在 Erlang 中创建项式时，它们是从元素开始自底向上创建的。垃圾收集器自顶向下工作，从顶层结构开始，然后复制元素。这意味着在第一次 GC 之后指针的方向会改变。这没有真正的含义，但是在查看实际堆时最好知道。你不能假设结构应该是自底向上的。

还要注意，GC 执行一口气第一次遍历。这意味着某个项式的局部性在 GC 之后通常会变得更糟。以现代缓存的大小，这应该不是问题。当然，您可以创建一个病态的示例，使其成为一个问题，但是您也可以创建一个病态示例，使深度优先方法导致问题。

第三件要注意的事情是，共享被保留了，这非常重要，否则我们可能会在 GC 之后使用比以前更多的空间。

Generations..

[ditaa]
----
  hend ->  +----+
           |....|
  stop ->  |    |
           |    |    +----+ old_hend
           |    |    |    |
  htop ->  |    |    |    |
           |....|    |    | old_htop
           |....|    |....|
  heap ->  +----+    +----+ old_heap
          The Heap   Old Heap


----

 +high_water, old_hend, old_htop, old_heap,
 gen_gcs, max_gen_gcs, off_heap,  mbuf, mbuf_sz, psd, bin_vheap_sz,
 bin_vheap_mature, bin_old_vheap_sz, bin_old_vheap+.

//  ==== TODO
//
// Growth of the stack and heap, Shrinking. No Stack overflow? 
//
// Random thoughts:
//
// Erlang has no updates - there can be no cycles: use reference count.
//
// Erlang terms are small.
//
// The HiPE group did some measures:
// 75% cons cells
// 24% !cons but smaller than 8 words
//  1% >= 8 words
//
// Less fragmentation & better locality with copying collector
//
// Advantages with 1 heap/process:
// + Free reclamation when a process dies
// + Small root set
// + Improved cache locallity
// + Cheap stack/heap test
//
// Disadvantages with 1 heap/process:
// - Message passing is expensive
// - Uses more space (fragmentation)
//

//  The garbage collector, generations, full sweep. 


// Put in pat II:
//  Getting information about stacks,
//  heaps and the GC. 
//  Tweaking stack and heap
//  parameters. 

// Hibernation. 

=== 其他有趣的内存区域（原书未完成）

原书未完成

==== 原子表（原书未完成）

原书未完成

==== 代码 （原书未完成）

原书未完成

==== 常量（原书未完成）

原书未完成


